name: deploy-jdk-complete

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - verify
        - destroy
  push:
    branches: [ main ]

env:
  TF_VERSION: "1.6.0"
  PYTHON_VERSION: "3.11"
  JDK_VERSION: "21.0.5_11"

jobs:
  terraform_apply:
    runs-on: ubuntu-latest
    if: ${{ (github.event.inputs.action == 'deploy' || github.event.inputs.action == 'verify' || github.event_name == 'push') }}
    outputs:
      instance_ids: ${{ steps.outputs.outputs.instance_ids }}
      bucket: ${{ steps.outputs.outputs.bucket }}
      s3_key: ${{ steps.outputs.outputs.s3_key }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create files directory
        run: mkdir -p files

      - name: Download OpenJDK installer
        run: |
          JDK_URL="https://github.com/adoptium/temurin21-binaries/releases/download/jdk-21.0.5%2B11/OpenJDK21U-jdk_x64_windows_hotspot_21.0.5_11.msi"
          JDK_FILE="files/OpenJDK21U-jdk_x64_windows_hotspot_21.0.5_11.msi"
          
          echo "üì• Downloading JDK installer..."
          curl -L -o "$JDK_FILE" "$JDK_URL"
          
          if [ ! -f "$JDK_FILE" ]; then
            echo "‚ùå Error: Failed to download JDK installer"
            exit 1
          fi
          
          echo "‚úÖ Downloaded JDK installer: $(ls -lh $JDK_FILE)"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform init
        working-directory: terraform
        run: |
          echo "üöÄ Initializing Terraform..."
          terraform init

      - name: Import existing resources if they exist
        working-directory: terraform
        continue-on-error: true
        run: |
          echo "üîç Checking and importing existing resources..."
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          
          # Import IAM Policy if exists
          if aws iam get-policy --policy-arn "arn:aws:iam::${ACCOUNT_ID}:policy/InstanceS3GetJdkPolicy" >/dev/null 2>&1; then
            echo "üì• Importing existing IAM policy..."
            terraform import aws_iam_policy.s3_get_policy "arn:aws:iam::${ACCOUNT_ID}:policy/InstanceS3GetJdkPolicy" || echo "Policy import failed or already in state"
          else
            echo "IAM policy not found, will be created"
          fi
          
          # Import IAM Role if exists
          if aws iam get-role --role-name "ec2-ssm-jdk-role" >/dev/null 2>&1; then
            echo "üì• Importing existing IAM role..."
            terraform import aws_iam_role.ec2_role "ec2-ssm-jdk-role" || echo "Role import failed or already in state"
          else
            echo "IAM role not found, will be created"
          fi
          
          # Import Instance Profile if exists
          if aws iam get-instance-profile --instance-profile-name "ec2-ssm-jdk-instance-profile" >/dev/null 2>&1; then
            echo "üì• Importing existing instance profile..."
            terraform import aws_iam_instance_profile.ec2_profile "ec2-ssm-jdk-instance-profile" || echo "Instance profile import failed or already in state"
          else
            echo "Instance profile not found, will be created"
          fi
          
          # Import policy attachments if they exist
          if aws iam list-attached-role-policies --role-name "ec2-ssm-jdk-role" --query 'AttachedPolicies[?PolicyName==`AmazonSSMManagedInstanceCore`]' --output text 2>/dev/null | grep -q "AmazonSSMManagedInstanceCore"; then
            echo "üì• Importing SSM policy attachment..."
            terraform import aws_iam_role_policy_attachment.ssm_managed "ec2-ssm-jdk-role/arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore" || echo "SSM policy attachment import failed or already in state"
          fi
          
          # Import custom policy attachment if exists
          if aws iam list-attached-role-policies --role-name "ec2-ssm-jdk-role" --query 'AttachedPolicies[?PolicyName==`InstanceS3GetJdkPolicy`]' --output text 2>/dev/null | grep -q "InstanceS3GetJdkPolicy"; then
            echo "üì• Importing custom policy attachment..."
            terraform import aws_iam_role_policy_attachment.attach_s3_get "ec2-ssm-jdk-role/arn:aws:iam::${ACCOUNT_ID}:policy/InstanceS3GetJdkPolicy" || echo "Custom policy attachment import failed or already in state"
          fi
          
          echo "‚úÖ Import process completed"

      - name: Terraform validate
        working-directory: terraform
        run: |
          echo "‚úÖ Validating Terraform configuration..."
          terraform validate

      - name: Terraform plan
        working-directory: terraform
        run: |
          echo "üìã Creating Terraform plan..."
          terraform plan \
            -var="local_installer_path=${{ github.workspace }}/files/OpenJDK21U-jdk_x64_windows_hotspot_21.0.5_11.msi" \
            -var="admin_password=${{ secrets.ADMIN_PASSWORD }}" \
            -out=tfplan

      - name: Terraform apply
        working-directory: terraform
        run: |
          echo "üèóÔ∏è Applying Terraform configuration..."
          terraform apply -auto-approve tfplan

      - name: Extract Terraform outputs
        id: outputs
        working-directory: terraform
        run: |
          echo "üì§ Extracting Terraform outputs..."
          terraform output -json > terraform_outputs.json
          cat terraform_outputs.json
          
          # Extract outputs with proper error handling
          INSTANCE_IDS=$(terraform output -json instance_ids 2>/dev/null | jq -c '.' || echo '[]')
          BUCKET=$(terraform output -raw s3_bucket 2>/dev/null || echo "")
          S3_KEY=$(terraform output -raw s3_key 2>/dev/null || echo "installers/OpenJDK21U-jdk_x64_windows_hotspot_21.0.5_11.msi")
          
          echo "üîç Debug outputs:"
          echo "  Instance IDs: $INSTANCE_IDS"
          echo "  S3 Bucket: $BUCKET"
          echo "  S3 Key: $S3_KEY"
          
          # Validation
          if [ -z "$BUCKET" ]; then
            echo "‚ùå Error: S3 bucket output is empty"
            exit 1
          fi
          
          if [ "$INSTANCE_IDS" = "[]" ] || [ -z "$INSTANCE_IDS" ]; then
            echo "‚ö†Ô∏è Warning: No instance IDs found"
          fi
          
          # Set outputs
          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT
          echo "bucket=$BUCKET" >> $GITHUB_OUTPUT
          echo "s3_key=$S3_KEY" >> $GITHUB_OUTPUT

  install_java:
    needs: terraform_apply
    runs-on: ubuntu-latest
    if: ${{ needs.terraform_apply.result == 'success' && needs.terraform_apply.outputs.instance_ids != '[]' && needs.terraform_apply.outputs.bucket != '' && github.event.inputs.action == 'deploy' }}
    steps:
      - name: Debug job inputs
        run: |
          echo "üêõ Debug Information:"
          echo "  Action: ${{ github.event.inputs.action }}"
          echo "  Event: ${{ github.event_name }}"
          echo "  Terraform result: ${{ needs.terraform_apply.result }}"
          echo "  Instance IDs: ${{ needs.terraform_apply.outputs.instance_ids }}"
          echo "  Bucket: ${{ needs.terraform_apply.outputs.bucket }}"
          echo "  S3 Key: ${{ needs.terraform_apply.outputs.s3_key }}"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Python and dependencies
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Ansible and AWS dependencies
        run: |
          echo "üì¶ Installing Ansible and dependencies..."
          python -m pip install --upgrade pip
          pip install ansible boto3 botocore
          ansible-galaxy collection install amazon.aws

      - name: Validate S3 object
        env:
          BUCKET: ${{ needs.terraform_apply.outputs.bucket }}
          KEY: ${{ needs.terraform_apply.outputs.s3_key }}
        run: |
          echo "üîç Validating S3 object exists..."
          if ! aws s3api head-object --bucket "$BUCKET" --key "$KEY" >/dev/null 2>&1; then
            echo "‚ùå Error: S3 object s3://$BUCKET/$KEY does not exist"
            aws s3 ls s3://$BUCKET/ || echo "Bucket listing failed"
            exit 1
          fi
          echo "‚úÖ S3 object validated: s3://$BUCKET/$KEY"

      - name: Generate presigned URL
        env:
          BUCKET: ${{ needs.terraform_apply.outputs.bucket }}
          KEY: ${{ needs.terraform_apply.outputs.s3_key }}
        run: |
          echo "üîó Generating presigned URL..."
          PRESIGNED_URL=$(aws s3 presign "s3://$BUCKET/$KEY" --expires-in 900)
          if [ -z "$PRESIGNED_URL" ]; then
            echo "‚ùå Error: Failed to generate presigned URL"
            exit 1
          fi
          echo "PRESIGNED_URL=$PRESIGNED_URL" >> $GITHUB_ENV
          echo "‚úÖ Presigned URL generated successfully"

      - name: Create Ansible playbook if missing
        run: |
          if [ ! -f "ansible/ssm_install_jdk.yml" ]; then
            echo "üìù Creating missing Ansible playbook..."
            mkdir -p ansible
            cat > ansible/ssm_install_jdk.yml << 'EOF'
          ---
          - name: Install JDK via SSM on Windows instances
            hosts: localhost
            gather_facts: false
            vars:
              aws_region: "{{ aws_region }}"
              instance_ids: "{{ instance_ids | from_json }}"
              s3_bucket: "{{ s3_bucket }}"
              s3_key: "{{ s3_key }}"
              presigned_url: "{{ presigned_url }}"
              
            tasks:
              - name: Display installation parameters
                debug:
                  msg:
                    - "Installing JDK on instances: {{ instance_ids }}"
                    - "S3 location: s3://{{ s3_bucket }}/{{ s3_key }}"
                    - "AWS Region: {{ aws_region }}"

              - name: Install JDK via SSM
                amazon.aws.aws_ssm_send_command:
                  region: "{{ aws_region }}"
                  instance_ids: "{{ instance_ids }}"
                  document_name: "AWS-RunPowerShellScript"
                  parameters:
                    commands:
                      - |
                        Write-Host "=== JDK Installation Started ==="
                        Write-Host "Timestamp: $(Get-Date)"
                        
                        # Set variables
                        $downloadUrl = "{{ presigned_url }}"
                        $installerPath = "C:\temp\jdk_installer.msi"
                        $logPath = "C:\temp\jdk_install.log"
                        
                        # Create temp directory
                        if (-not (Test-Path "C:\temp")) {
                            New-Item -ItemType Directory -Path "C:\temp" -Force
                        }
                        
                        try {
                            # Download JDK installer
                            Write-Host "üì• Downloading JDK installer..."
                            Invoke-WebRequest -Uri $downloadUrl -OutFile $installerPath -UseBasicParsing
                            
                            if (-not (Test-Path $installerPath)) {
                                throw "Downloaded installer not found"
                            }
                            
                            Write-Host "‚úÖ Download completed: $(Get-Item $installerPath | Select-Object Name, Length)"
                            
                            # Install JDK silently
                            Write-Host "üîß Installing JDK..."
                            $installArgs = @(
                                "/i", $installerPath,
                                "/quiet",
                                "/norestart",
                                "/log", $logPath,
                                "ADDLOCAL=FeatureMain,FeatureEnvironment,FeatureJarFileRunWith,FeatureJavaHome"
                            )
                            
                            $process = Start-Process -FilePath "msiexec.exe" -ArgumentList $installArgs -Wait -PassThru
                            
                            if ($process.ExitCode -eq 0) {
                                Write-Host "‚úÖ JDK installation completed successfully"
                            } else {
                                Write-Host "‚ùå JDK installation failed with exit code: $($process.ExitCode)"
                                if (Test-Path $logPath) {
                                    Write-Host "Installation log:"
                                    Get-Content $logPath | Select-Object -Last 20
                                }
                                throw "Installation failed"
                            }
                            
                            # Verify installation
                            Write-Host "üîç Verifying installation..."
                            
                            # Refresh environment variables
                            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
                            
                            # Test Java command
                            $javaVersion = & java -version 2>&1 | Out-String
                            Write-Host "Java version output: $javaVersion"
                            
                            # Check JAVA_HOME
                            $javaHome = [System.Environment]::GetEnvironmentVariable("JAVA_HOME", "Machine")
                            if ($javaHome) {
                                Write-Host "‚úÖ JAVA_HOME set to: $javaHome"
                            } else {
                                Write-Host "‚ö†Ô∏è JAVA_HOME not set"
                            }
                            
                            Write-Host "=== Installation Complete ==="
                            
                        } catch {
                            Write-Host "‚ùå Installation failed: $($_.Exception.Message)"
                            if (Test-Path $logPath) {
                                Write-Host "Installation log:"
                                Get-Content $logPath
                            }
                            throw
                        } finally {
                            # Cleanup
                            if (Test-Path $installerPath) {
                                Remove-Item $installerPath -Force
                            }
                        }
                  wait_for_results: true
                  max_wait_time: 600
                register: install_result

              - name: Display installation results
                debug:
                  msg: "Instance {{ item.instance_id }}: {{ item.status }} - {{ item.stdout if item.stdout else 'No output' }}"
                loop: "{{ install_result.invocations }}"

              - name: Check for installation failures
                fail:
                  msg: "JDK installation failed on one or more instances"
                when: install_result.invocations | selectattr('status', 'equalto', 'Failed') | list | length > 0
          EOF
            echo "‚úÖ Ansible playbook created"
          fi

      - name: Run JDK installation
        env:
          PRESIGNED_URL: ${{ env.PRESIGNED_URL }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          INSTANCE_IDS: ${{ needs.terraform_apply.outputs.instance_ids }}
          BUCKET: ${{ needs.terraform_apply.outputs.bucket }}
          S3_KEY: ${{ needs.terraform_apply.outputs.s3_key }}
        run: |
          echo "üöÄ Starting JDK installation via SSM..."
          ansible-playbook ansible/ssm_install_jdk.yml \
            -e "instance_ids=$INSTANCE_IDS" \
            -e "s3_bucket=$BUCKET" \
            -e "s3_key=$S3_KEY" \
            -e "presigned_url=$PRESIGNED_URL" \
            -e "aws_region=$AWS_REGION" \
            -v

  verify_java:
    needs: [terraform_apply, install_java]
    runs-on: ubuntu-latest
    if: ${{ always() && needs.terraform_apply.result == 'success' && needs.terraform_apply.outputs.instance_ids != '[]' && (needs.install_java.result == 'success' || github.event.inputs.action == 'verify') }}
    steps:
      - name: Debug job inputs
        run: |
          echo "üêõ Verification Debug:"
          echo "  Action: ${{ github.event.inputs.action }}"
          echo "  Terraform result: ${{ needs.terraform_apply.result }}"
          echo "  Install result: ${{ needs.install_java.result }}"
          echo "  Instance IDs: ${{ needs.terraform_apply.outputs.instance_ids }}"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Python and dependencies
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Ansible and AWS dependencies
        run: |
          echo "üì¶ Installing Ansible and dependencies..."
          python -m pip install --upgrade pip
          pip install ansible boto3 botocore
          ansible-galaxy collection install amazon.aws

      - name: Get instance IDs for verification
        id: get_instances
        run: |
          if [ "${{ github.event.inputs.action }}" = "verify" ]; then
            echo "Getting instances from Terraform state..."
            cd terraform
            terraform init
            INST_IDS=$(terraform output -json instance_ids 2>/dev/null | jq -c '.' || echo '[]')
          else
            INST_IDS="${{ needs.terraform_apply.outputs.instance_ids }}"
          fi
          echo "INST_IDS=$INST_IDS" >> $GITHUB_ENV
          echo "Instance IDs for verification: $INST_IDS"

      - name: Create verification playbook
        run: |
          echo "üìù Creating Java verification playbook..."
          mkdir -p ansible
          cat > ansible/verify_java.yml << 'EOF'
          ---
          - name: Verify Java Installation
            hosts: localhost
            gather_facts: false
            vars:
              aws_region: "{{ aws_region }}"
              instance_ids: "{{ instance_ids | from_json }}"
            
            tasks:
              - name: Verify Java installation via SSM
                amazon.aws.aws_ssm_send_command:
                  region: "{{ aws_region }}"
                  instance_ids: "{{ instance_ids }}"
                  document_name: "AWS-RunPowerShellScript"
                  parameters:
                    commands:
                      - |
                        Write-Host "=== Java Verification Report ==="
                        Write-Host "Timestamp: $(Get-Date)"
                        Write-Host "Computer: $env:COMPUTERNAME"
                        Write-Host ""
                        
                        $verificationPassed = $true
                        
                        try {
                            # Test Java command
                            Write-Host "üîç Testing Java command..."
                            $javaVersionOutput = & java -version 2>&1
                            if ($LASTEXITCODE -eq 0) {
                                Write-Host "‚úÖ Java command is accessible"
                                Write-Host "Version output:"
                                $javaVersionOutput | ForEach-Object { Write-Host "  $_" }
                            } else {
                                Write-Host "‚ùå Java command failed"
                                $verificationPassed = $false
                            }
                        } catch {
                            Write-Host "‚ùå Java command not found in PATH"
                            $verificationPassed = $false
                        }
                        
                        # Check JAVA_HOME
                        Write-Host ""
                        Write-Host "üîç Checking JAVA_HOME..."
                        $javaHome = [System.Environment]::GetEnvironmentVariable("JAVA_HOME", "Machine")
                        if ($javaHome) {
                            Write-Host "‚úÖ JAVA_HOME is set to: $javaHome"
                            if (Test-Path "$javaHome\bin\java.exe") {
                                Write-Host "‚úÖ Java executable found in JAVA_HOME"
                            } else {
                                Write-Host "‚ö†Ô∏è Java executable NOT found in JAVA_HOME"
                                $verificationPassed = $false
                            }
                        } else {
                            Write-Host "‚ö†Ô∏è JAVA_HOME environment variable is not set"
                        }
                        
                        # Check PATH
                        Write-Host ""
                        Write-Host "üîç Checking PATH for Java..."
                        $pathDirs = $env:PATH -split ';'
                        $javaInPath = $false
                        foreach ($dir in $pathDirs) {
                            if ($dir -and (Test-Path "$dir\java.exe")) {
                                Write-Host "‚úÖ Java found in PATH: $dir"
                                $javaInPath = $true
                                break
                            }
                        }
                        if (-not $javaInPath) {
                            Write-Host "‚ö†Ô∏è Java not found in PATH"
                        }
                        
                        # Final result
                        Write-Host ""
                        Write-Host "=== Verification Summary ==="
                        if ($verificationPassed) {
                            Write-Host "‚úÖ PASS: Java is properly installed and configured"
                        } else {
                            Write-Host "‚ùå FAIL: Java installation has issues"
                            exit 1
                        }
                        Write-Host "=== End of Report ==="
                  wait_for_results: true
                  max_wait_time: 120
                register: verification_result

              - name: Display verification results
                debug:
                  msg: |
                    Instance: {{ item.instance_id }}
                    Status: {{ item.status }}
                    Output: {{ item.stdout | default('No output') }}
                    {% if item.stderr %}Error: {{ item.stderr }}{% endif %}
                loop: "{{ verification_result.invocations }}"

              - name: Check verification status
                fail:
                  msg: "Java verification failed on one or more instances"
                when: verification_result.invocations | selectattr('status', 'equalto', 'Failed') | list | length > 0
          EOF

      - name: Run Java verification
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          INST_IDS: ${{ env.INST_IDS }}
        run: |
          echo "üîç Starting Java verification..."
          ansible-playbook ansible/verify_java.yml \
            -e "instance_ids=$INST_IDS" \
            -e "aws_region=$AWS_REGION" \
            -v

  terraform_destroy:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.action == 'destroy' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform init
        working-directory: terraform
        run: |
          echo "üöÄ Initializing Terraform for destroy..."
          terraform init

      - name: Show destroy plan
        working-directory: terraform
        run: |
          echo "üìã Showing what will be destroyed..."
          terraform plan -destroy \
            -var="local_installer_path=dummy_path" \
            -var="admin_password=${{ secrets.ADMIN_PASSWORD }}"

      - name: Terraform destroy
        working-directory: terraform
        run: |
          echo "üóëÔ∏è Destroying infrastructure..."
          terraform destroy -auto-approve \
            -var="local_installer_path=dummy_path" \
            -var="admin_password=${{ secrets.ADMIN_PASSWORD }}"

      - name: Cleanup verification
        run: |
          echo "‚úÖ Infrastructure destruction completed!"
          echo ""
          echo "üîç Please verify in AWS Console that these resources are removed:"
          echo "  ‚Ä¢ EC2 instances"
          echo "  ‚Ä¢ S3 buckets and objects"
          echo "  ‚Ä¢ IAM roles and policies"
          echo "  ‚Ä¢ Security groups"
          echo "  ‚Ä¢ VPC and networking components"
